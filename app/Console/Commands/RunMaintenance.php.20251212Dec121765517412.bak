<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Symfony\Component\Process\Process;

class RunMaintenance extends Command
{
    /**
     * The name and signature of the console command.
     */
    protected $signature = 'system:maintenance {--skip-npm : Skip npm install and build}';

    /**
     * The console command description.
     */
    protected $description = 'Run a full Laravel optimization and cleanup sequence including composer and npm.';

    /**
     * Command timeout in seconds (15 minutes for npm)
     */
    protected $timeout = 900;

    /**
     * Execute the console command.
     */
    public function handle(): int
    {
        $isProduction = app()->environment('production');
        $environment = $isProduction ? 'PRODUCTION' : 'DEVELOPMENT';

        $this->info("ðŸš€ Starting Laravel optimization routine [{$environment}]...");
        $this->newLine();

        // Phase 0: Storage cleanup (safe for both dev and prod)
        $this->info('ðŸ§¹ Cleaning storage directories...');
        $this->cleanStorage();
        $this->newLine();

        // Phase 1: Dependency updates
        $composerCommand = $isProduction
            ? 'composer install --no-dev --optimize-autoloader'
            : 'composer install';

        $dependencyCommands = [$composerCommand];

        // Add npm commands unless --skip-npm flag is used
        if (! $this->option('skip-npm')) {
            $this->warn('âš ï¸  npm build will clear browser storage (may log you out of websites)');
            $dependencyCommands[] = 'npm install';
            $dependencyCommands[] = 'npm run build';
        } else {
            $this->warn('âš ï¸  Skipping npm install and build (--skip-npm flag detected)');
        }

        // Phase 2: Laravel optimization - SAFE VERSION (no config caching)
        $optimizationCommands = [
            'php artisan optimize:clear',      // Clears config, route, view, cache
            'php artisan clear-compiled',
            'php artisan event:clear',
        ];

        // Only add debugbar:clear if the command exists (dev environment)
        //        if ($this->commandExists('debugbar:clear')) {
        //            $optimizationCommands[] = 'php artisan debugbar:clear';
        //        }

        $optimizationCommands = array_merge($optimizationCommands, [
            'composer dump-autoload -o',
            'php artisan package:discover --ansi',
        ]);

        // Add platform-specific bootstrap cache cleanup
        if (PHP_OS_FAMILY === 'Windows') {
            array_unshift($optimizationCommands, 'del /f /q bootstrap\cache\*.php 2>nul');
        } else {
            array_unshift($optimizationCommands, 'rm -f bootstrap/cache/*.php 2>/dev/null');
        }

        // SAFE OPTIMIZATION - Only cache routes and views, NOT config
        if ($isProduction) {
            $this->info('ðŸ”§ Running safe optimization (caching routes/views only)...');
            $optimizationCommands = array_merge($optimizationCommands, [
                'php artisan route:cache',   // Safe to cache
                'php artisan view:cache',    // Safe to cache
            ]);
        }

        $allCommands = array_merge($dependencyCommands, $optimizationCommands);

        // Add progress bar
        $progressBar = $this->output->createProgressBar(count($allCommands));
        $progressBar->start();

        foreach ($allCommands as $command) {
            $this->line("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            $this->line("  Running: {$command}");
            $this->line("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

            $process = Process::fromShellCommandline($command, base_path());
            $process->setTimeout($this->timeout);

            $process->run(function ($type, $buffer) {
                echo $buffer;
            });

            if (! $process->isSuccessful()) {
                $this->error("âŒ Command failed: {$command}");
                $this->error($process->getErrorOutput());

                // Don't fail completely if npm build fails
                if (str_contains($command, 'npm')) {
                    $this->warn('âš ï¸  Continuing despite npm error...');
                    $progressBar->advance();
                    $this->newLine();

                    continue;
                }

                return self::FAILURE;
            }

            $this->info("âœ… Completed: {$command}");
            $progressBar->advance();
            $this->newLine();
        }

        $progressBar->finish();
        $this->newLine(2);
        $this->info('ðŸŽ¯ All optimization tasks completed successfully!');
        $this->info('âœ… Sessions preserved - users will remain logged in');
        $this->newLine();

        // Reminder for PM2
        $this->warn('ðŸ“ REMINDER: Don\'t forget to run PM2 commands manually:');
        $this->line('   pm2 status                          # Check if Reverb is running');
        $this->line('   pm2 restart laravel-reverb          # Restart Reverb server');
        $this->line('   pm2 logs laravel-reverb --lines 20  # View recent logs');
        $this->line('   pm2 save                            # Save current setup');
        $this->newLine();

        return self::SUCCESS;
    }

    /**
     * Check if an artisan command exists.
     */
    protected function commandExists(string $command): bool
    {
        try {
            // Method 1: Check if command is registered in the application
            $artisan = $this->getApplication();
            if ($artisan->has($command)) {
                return true;
            }

            // Method 2: Try to run help command for the specific command
            $process = Process::fromShellCommandline("php artisan {$command} --help", base_path());
            $process->setTimeout(10);
            $process->run();

            return $process->isSuccessful();

        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Clean storage directories - removes logs and cache safely.
     * NOTE: Sessions are NOT cleaned to preserve user logins and Livewire state.
     */
    protected function cleanStorage(): void
    {
        $storagePath = storage_path();

        $cleanDirs = [
            'logs' => $storagePath.'/logs/*.log',
            'framework/cache/data' => $storagePath.'/framework/cache/data/*',
            // REMOVED: Sessions cleanup - this was causing logout issues and Livewire errors
            // Laravel handles session expiry automatically via garbage collection
            'framework/views' => $storagePath.'/framework/views/*',
        ];

        foreach ($cleanDirs as $name => $pattern) {
            $this->line("  Cleaning {$name}...");

            if (PHP_OS_FAMILY === 'Windows') {
                $command = 'del /f /q '.str_replace('/', '\\', $pattern).' 2>nul';
            } else {
                $command = 'rm -f '.$pattern.' 2>/dev/null';
            }

            $process = Process::fromShellCommandline($command, base_path());
            $process->run();

            if ($process->isSuccessful() || $process->getExitCode() === 1) {
                $this->info("  âœ“ Cleaned {$name}");
            } else {
                $this->warn("  âš    Could not clean {$name} (may not exist)");
            }
        }

        // Recreate laravel.log
        $logFile = $storagePath.'/logs/laravel.log';
        if (! file_exists($logFile)) {
            touch($logFile);
            $this->info('  âœ“ Created fresh laravel.log');
        }
    }
}
